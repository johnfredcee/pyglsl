#ifndef FBXPARSE_H
#define FBXPARSE_H

#include <vector>
#include <string>

#include <aqua/TextureSlotData.h>

namespace FBXFILESDK_NAMESPACE {
class FbxScene;
class FbxDisplayLayer;
class FbxMesh;
};

namespace aqua {
class Material;
};

/** Class to parse an fbx scene and extract various useful bits of
	information out of it */
class FbxParse {
public:
	/**
	 * Constructor: Associate a scene with the parser
	 * @param scene Pointer to scene
	 */
	FbxParse(FbxScene* scene);

	/** Destructor **/
	virtual ~FbxParse();

	/**
	 * Return the root node of the scene we are parsing
	 * @return Root Node
	 */
	FbxNode* FbxParse::getSceneRoot() {
		return ( scene_ == NULL ) ? NULL : scene_->GetRootNode();
	}
	
	/**
	 * Fill a vector with pointers to the fbx display layers in the scene
	 * @param layers vector of FbxDisplayLayer*'s (might be empty if none)
	 */
	void layers(std::vector<FbxDisplayLayer*>& layers);

	/**
	 * Fill a vector of node pointers with the nodes of the objects inside the display layers
	 * @param layer Layer to 
	 * @param nodes Vector of nodes to fill
	 */
	void getLayerNodes(FbxDisplayLayer* layer, std::vector<FbxNode*>& nodes);

	/**
	 * Return a list of layer names in the scene
	 * @param layerNames vector to store layer names in
	 */
	void layerNames(std::vector<std::string>& layerNames);

	/**
	 * Get root nodes of a certian type from the scene
	 * @param type class Id of type to extract
	 * @param nodes vector of nodes to populate
	 */
	void getNodes(FbxClassId& type, std::vector<FbxNode*>& nodes);

	/**
	 * GetDisplayLayer
	 * Returns the display layer ( == Max layer) a given node is in
	 * @param pNode Node to return layer of
	 * @return FbxDisplayLayer* Pointer to display layer of node
	 */
	FbxDisplayLayer* getDisplayLayer(FbxNode* pNode);
	
	/**
	 * Given a material name, return the shader portion of the name
	 * TOD : This is not strictly an fbx function - should move to MaterialNameManager
	 * @param name material name
	 * @return shader name portion of material name or "default"
	 */
	std::string	 getShaderName(const std::string& name);

	/**
	 * Get the global transform that is generated by animation for sampling purposes
	 * @param pNode Node to sample transform of
	 * @return the global transform
	 */
	FbxAMatrix getGlobalDefaultTransform(FbxNode* pNode, KTime& pTime, FbxAMatrix* pParentGlobalTransform = NULL);

    /**
	 * Description for getAnimatedNodeTransform.
	 * @param node Node to sample trasnform of
	 * @param time time to sample node transform at
	 * @return sampled FbxAMatrix
	 */
	FbxAMatrix getAnimatedNodeTransform(FbxNode* node, KTime time);
		
	/**
	 * Description for setAnimationContext.
	 * @param animStackName <doc>
	 * @param start <doc>
	 * @param stop <doc>
	 * @return <doc>
	 */
	FbxAnimStack* setAnimationContext(KString* animStackName, KTime& start, KTime& stop);	


	/**
	 * Fish a named generic node out of the scene.
	 * Used for finding splines and other nodes that carry custom data
	 * @param soughtString name of node to find
	 * @return pointer to generic node in associated scene or NULL
	 */
	FbxGenericNode* getNamedGenericNode(const KString& soughtString);

private:
	//!< The scene we are parsing
	FbxScene *scene_;
};


/**
 *	Get the geometry deformation local to a node. It is never inherited by the children.
 * @param pNode node to get geometry
 * @return geometry/offest transform
 */
FbxAMatrix getGeometryTransform(FbxNode* pNode);

/**
 * Convert a FBX matrix to playbox matrix conventions
 * @param transform Matrix to transform
 * @return pointer to playbox matrix
 */
aqua::shared_ptr<aqua::PbMatrix4> fbxToPlayboxTransform(const FbxAMatrix& transform);


/**
 * Return the transform associated with an fbx node
 * This version is absolute - parent transforms are post
 * multiplied in.
 * @param pNode node to extract transform of
 * @return Transform in FbxMatrix
 */
FbxAMatrix getNodeTransform(FbxNode* pNode);

/**
 * Return the transform associated with a node.
 * @param pNode
 * @return FbxAMatrix
 */
FbxAMatrix getNodeLocalTransform(FbxNode* node);

wxString getNodeDescription(FbxNode* pNode);

void parseLayers(FbxNode* pNode,
				FbxMesh* pMesh,
				std::vector<int>& usedMaterials,
				std::vector<int>& usedMaterialsIndex,
				std::vector<std::string>& uvSetNames);

void parseFbxNodeMaterial(aqua::shared_ptr<aqua::Material> material,
						FbxNode* pNode,
						FbxMesh* mesh,
						int materialIndex,
						std::string& name,
						std::string& shaderName);
	

TextureBlendMode parseFbxBlendMode(FbxLayeredTexture::EBlendMode blendMode);

#endif
